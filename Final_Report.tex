\documentclass{article} % For LaTeX2e
\usepackage[final]{colm2025_conference}

\usepackage{microtype}
\usepackage{hyperref}
\usepackage{url}
\usepackage{booktabs}

\usepackage{lineno}
\usepackage{amsmath}

\definecolor{darkblue}{rgb}{0, 0, 0.5}
\hypersetup{colorlinks=true, citecolor=darkblue, linkcolor=darkblue, urlcolor=darkblue}


\title{Aggie Wine Glass: A By-The-Glass Wine Finder and \\ Recommendation System}

% Authors must not appear in the submitted version. They should be hidden
% as long as the \colmfinalcopy macro remains commented out below.
% Non-anonymous submissions will be rejected without review.

\author{Maya Shah, Ariela Mitrani \& Gabriel Wild\\
Department of Computer Science\\
Texas A\&M University\\
College Station, TX 77840, USA \\
}

% The \author macro works with any number of authors. There are two commands
% used to separate the names and addresses of multiple authors: \And and \AND.
%
% Using \And between authors leaves it to \LaTeX{} to determine where to break
% the lines. Using \AND forces a linebreak at that point. So, if \LaTeX{}
% puts 3 of 4 authors names on the first line, and the last on the second
% line, try using \AND instead of \And before the third author name.

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}

\ifcolmsubmission
\linenumbers
\fi

\maketitle

\begin{abstract}

Aggie Wine Glass helps Texas A\&M students discover local restaurants and bars that serve wines matching their preferences by the glass. Based on user-inputted taste preferences, pairing requests, and other factors, our recommendation tool provides a curated list of nearby establishments where these wines are available, making wine tasting more accessible and budget-friendly for students. This tool allows users to draw from over 400 by-the-glass wine options in College Station in order to identify places to try new wines without buying bottles. It also helps recommend wines based on existing ratings for the bottles online, and is integrated with LLMs at various steps to give more tailored/specific recommendations.

\end{abstract}

\section{Motivation}

For many college students looking to explore the world of wine tasting, it can be challenging to find local tasting opportunities or try new wines without committing to an entire bottle. Aggie Wine Glass solves this problem by combining a database of wines and their key attributes with an understanding of college student budgets and local availability. Our tool helps Texas A\&M students discover by-the-glass wine options at nearby venues in Bryan-College Station, making wine tasting more accessible, affordable, and convenient. Currently, there are no existing tools that exist to find by-the-glass wine options, so this is fixing a big gap in the market. Similar tools do exist, but not with the specific functionality we provide. Many websites exist to help locate stores to buy wine bottles, and many list important characteristics of the wine such as grape variety, region, and flavor profile. Vivino, for example, is a well-known website and app that allows users to filter wines based on various attributes, leave reviews, and even purchase bottles. However, it does not help users find restaurants or bars where they can try wines by the glass, nor does it allow for filtering top wine lists for specific cities. While our app has some similar features to existing technologies, the main goal is to provide a way for users to find wine tasting recommendations in their area without having to manually scour different restaurant menus. 

\section{Data Collection}

Before we started this project, we identified that building the database of local wines would be the most difficult part of our implementation. In order to have a high-performing system, we needed to compile a sizable number of different wines and many different characteristics of each of these wines. While we searched for an existing wine API to gather information about the wines offered at local restaurants, we did not find a publicly available API we could use, and thus had to create our own web scraper. Creating the database was a two step process: Collecting a list of restaurants, their wines and their prices, and  extracting the characteristics of each wine.

\subsection{Menu Processing}

The first part of the database building process was finding restaurants that had by-the-glass wine offerings, and then processing the information from their menus into a standardized format with the wine name, restaurant name, and glass price. The first obstacle was that not every restaurant in College Station with wine offerings had an online menu. Because of this, we did ground research and physically went to take photos of wine lists for the restaurants that did not have their wine menus posted online. 

From here, we had to extract the relevant information from the menus and put it into a Google Sheet. While this can be done manually by copy-pasting the wine name and the price, this would be incredibly inefficient, especially with over 400 wines from more than 20 different websites. Instead, these menus were copy pasted into ChatGPT, who then outputted the wines and their prices in a table format. This data still had to be manually revised and occasionally changed due to errors in ChatGPT's processing, but using an LLM for this preprocessing step sped up the process exponentially.

An important trend we discovered during this step was that many local restaurants offered the same wine. However, the labeling convention on wine menus differed. In order to make sure that our system recognized these wines as the same wine, we used wine IDs to identify when two wines were the same, regardless of naming convention. The details of this ID and the other wine information follow in the next section.

\subsection{Vivino Data Collection}

The second half of the database building involved getting information about the wine characteristics. For each wine, we extracted the following data points: Bottle Price, Winery, Year, Wine Style, Region, Grape Varieties,	ABV,	Dry/Sweet	 Rating, Tannin Rating, Soft/Acidic Rating, Flavor Profile, Pairings, Rating,	 Category, Light/Bold	 Rating, Profile Specifics, Fizziness, Country, and Wine ID. To get these characteristics, we used Vivino as our base. Vivino is a wine database that has information on a large variety of different wines, as well as user ratings. Using Vivino allowed us to take all of the characteristics from one place, ensuring consistency in these metrics across different wines. 

The information in each of these categories is scattered throughout various places in both the page's HTML and separate JSON files, so our scraping approach required a mix of both types of request. By sending an HTML request to a wine's Vivino page, we can extract most of the characteristics, as well as the wine's ID. The taste characteristics required an additional call to Vivino's taste API, which used the ID in the request URL. Most of the HTML locations for these characteristics were found by manually going through the HTML and locating the regions where the information showed up, as well as monitoring network requests to see which information came from a separate API call.

To use this scraper, we needed the Vivino link for each of the individual wines in the list. Unfortunately, there was not a good way to automate this, especially because some of the wines were challenging to match to Vivino pages, or there were multiple different pages for one type of wine. Therefore, the link finding was done manually. A general page (no year information) was found for the wines that didn't have a vintage specified on the menus, and the ones that did had the link to that specific vintage used.

Not every wine has a complete profile on Vivino. This meant that even after running our scraper on all of the links, there were still gaps in the wine profiles. To have a complete data set, every attribute except for year needed to be filled in. To this end, we used Gemini through Jupyter Notebook to fill in the missing attributes for these wines. However, knowing Gemini isn't perfect, we also did validation on these results. While Gemini was instructed not to change any of the data that was already present, it occasionally would for one of two reasons - the data scraped from Vivino was inaccurate, or Gemini was unfamiliar with the wine. To deal with the first case, all cases where Gemini's output differed from our scraper's were highlighted and manually resolved. For the second case, we passed the entire dataset through ChatGPT and asked it to identify any characteristics that were very atypical and likely wrong, and corrected these as well.

\subsection{Drawbacks and Challenges}

There are a few key drawbacks with our approach. The first involves the data being scraped from Vivino. Initially, we were also getting price from a separate pricing API, but due to issues with Vivino's currency (occasionally returning in other currencies like TWD with no clear conversion to the USD amount), we scrape these from the HTML as well. However, because the most accurate price data comes from the pricing API, the bottle prices we found are not always exact or even matched what Vivino had listed. In addition, even for the data that we scraped accurately every time, Vivino itself is not an objective source. Many users have complained about biased ratings on the site, and the tasting profiles listed are based on users reviews, which can be inaccurate. Also, Vivino's backend can change drastically between wines, making it hard or impossible to accurately scrape the same type of data from different wines.

Another issue with this method is that menus change. Especially in regards to wine selection, restaurants will often change what they are offering based on what is available, and rotate through these rather quickly. However, both of these issues could be resolved if we were to continue working on this project by allowing restaurants that want to participate to input their own data. With something like a restaurant account, every restaurant could put its wines in and make sure their profiles are accurate. However, due to the scope of this project, scraping Vivino and using currently available menus was the best approach. The above is just an example of future work that could be done to mitigate some of these issues.

\section{Recommendation Algorithm}

After getting the data, the next step in the development of Aggie Wine Glass was to develop the ranking and similarity assessment algorithm that would allow for user preference inputs to be utilized in the development of a final recommendation list of wines. 

\subsection{Obtaining User Input}
The initial stage in developing the algorithm required getting a basline on user preferences as it related to different wine characteristics. Through the data collection, knowledge learned in Texas A\&M's HORT 416 Understanding Wine -- - From Vines to Wines and Beyond Course, and a little bit of external reseearch, it was deternined that there were various characteristics that we could gather user input on.

Our dataset identified six different categories of wines -- Red, White, Sparkling, Rose, Dessert, and Fortified. Therefore, the first characteristic for which user input is desired is on the selection of wine categories for which the user interested in recieving recommendations.  

Next comes the input of user ratings on scalar attributes relating to the taste of the wine. Users are presnted with five different scalar attributes -- Dry/Sweet, Tannin, Soft/Acidic, Light/Bold, and Fizziness. Users are asked to rate their preferences for the first four attributes on a scale of 1 - 5 and on a scale of 0 - 5 for the last attribute. These scalar values will be used later to calculate a weighted cosine similarity assessment between user preferences and our collection of wines.

Through the collection of information on the wines in our dataset, we were able to determine that each of the wines falls into one of the four following region categories -- Texas, US Non-Texas, New World (Australia/Asia), and Old World (Europe). Users then provide input on what regions of the world they would like their wines to be originating from. 

Now, we move onto our categorical data components. Users select the flavor profiles that they feel align the best with their wine flavor interests. On the back-end, our wine object model had two different attributes, one for flavor profiles and one for profile specifics. There is also a mapping different profile specifics and their assoicated flavor profile. As a result, once a user selects all their desired flavor profiles, their associated flavor profiles are set to a numerical baseline score of 3.0, and all profile specifics are set to a numerical baseline score of 1.0. These numerical baseline values are further adjusted during the fine-tuning process and first buffered and then used in order to calculate a weighted jaccard similiarity based on the user's flavor preferences. 

The last piece of categorical data that the user is able to provide preference input on is the optional food pairings section. If desired, users are able to select the type of foods that they are interested in pairing their wine with. As a result, the back-end would populated the desired food pairtings with a numerical baseline score of 1.0 and later calculate a jaccard similairty score between the wines in our database and the user input preferences. 

Lastly, the user selects the less of personalization they desire. They can select eitther less or more, and this determines the amount of fine-tuning that is applied to the user's basline preferences.

\subsection{Fine-Tuning}
The purpose of fine-tuning is to be able to provide a more accurate estimate of what the user really likes. A hard filter is applied to the dataset based on the selected categories and regions. Then, users are presented with anoymous wine's for which they are provided the following information: 
category type, all 5 scalar attributes, and 3 of the 5 profile specifics associated with the given wine. Users then have the ability to "like" or "dislike" the wine.

These anonymous wine profiles are generated in "mini-sets". The number of mini-sets are set based on the level of personalization that the user selected, and the number of wine categories that the user selected. We wanted to be sure to give the user enough cards to get a more accurate assessment of their wine preferences, but not too many cards to where they lost interest.

The mini-sets are comprised in two different ways. For the categories of rose, dessert, and fortified wines, we only have 21, 12, and 12 wines respectively. As a result, each mini-set is composed soley of one wine in the category that is picked at random. However, for the categories of red, white, and sparkling, for wine we have substantially larger numbers of wines, each mini-set contains 3 anonymous wine profiles. The first wine is selected based on the user's taste preferences. A weighted cosine similarity score is calculated on the 5 scalar attributes. A wine is then picked from random from the top 20 most similar wines. A similar process takes place for the second wine. However, this wine is selected based on the user's flavor preferences. As a result, a weighted jaccard similarity score is calculated against the wines in the database and one is selected from the top 20 scores. Lastly, the third wine is simply picked at random from those that match in category. 

After each set is generated, the user "likes" or "dislikes" the given wines. Then, based on the resulting user information about these anonymous wine profiles, their baseline preferences are fine-tuned. For every wine that the user likes, the associated flavor profile score are increased by 1.0 and the scores of the 3 presented flavor specifics are increased by 0.25. If the user disliked the wine, flavor profile scores are decreassed by 1.0 and the 3 presented flavor specifics scores are decreased by 0.25. For all liked wines, their scalar attributes are averaged and the recomputed with the current baseline values to create a new weighted average between the two measures that replaced the current baseline. 

The next x iterations of mini-sets that the user is presented with is calcualted based on the fine-tuning updates of the previous mini-set. This ensures that each mini-set is further enhancing the accuracy of our information on user preferences, rather than all being selected on the initial baseline.

After the user has been presented with all the minisets, and has "liked" or "disliked" all given anonymous wine profiles, the final similarity recommendation can be conducted. 

\subsection{Similarity Assessment}
The final similarity assessment was calculated by adding various similairty scores together. First, however; there was a hard filter applied to the total databased that included user categories, regions, and buffered scalar taste attributes. This provided the filtered list on which  similarity scores were calculated. First a weighted cosine score was calculated. The weights 0.20, 0.20, 0.30, 0.20, 0.10 mapped to Dry/Sweet, Tannin, Soft/Acidic, Light/Bold, Fizziness respectively. This scores were mapped to their wine's id and stored. Next, a weighted jaccard similarity was calculated on both the flavor profiles and flavor specifics of each wine and the scores of matching user preferences. Both these scores were stored and mapped to the associated wine id, very similar to the weighted cosine calculation. The user rating for the wine that was scraped from Vivno is also taken into consideration. If food pairing were selected, a jaccard similarity score was also calculated and mapped to the respective wine id. Thus the similarity assessment algorithms are as follows. Equation (5) is used when the user does not select the option to pair and equation (6) is used when the user does decide to pair.
\begin{align}
taste &= weightedCosineScore \\
flavorProfiles &= weightedJaccardScore \\
profileSpecifics &= weightedJaccardScore \\
foodPairings &= jaccardScore \\
ranking &= (taste * 0.25) + (flavorProfiles * 0.25) + {} \notag \\
         &\quad (profileSpecifics * 0.25) + (vivinoRating * 0.25) \\
ranking &= (taste * 0.20) + (flavorProfiles * 0.20) + {} \notag \\
         &\quad (profileSpecifics * 0.20) + (vivinoRating * 0.20) + {} \notag \\
         &\quad (foodPairings * 0.20)
\end{align}

The resulting similairty scores are on a scale of 0 - 1, with 0 being the least similar and 1 being the most similar. At this point, a top recommendation is pulled from each category the user selected. The top wine is either selected at random from any wine with a similarity score >= 0.90, or if none of the scores are >= 0.90, it is pulled at random from the top 10\% of the highest scoring similar wines. For red and white, since we have such a large number of those categories in our dataset, the user is presented with two top recommendations, while the remains categories present one top recommendation. The user is also presented with another section of "adventurous recommendations". These wines either have a simialrity score >= 0.70 and <0.90 or are pulled from between the top 10\% and the top 20\% of similarity scores. This wines don't align as highly with the user preferences, but are still likely to wines that align with user preferences and encourage them to branch out. 

This completes the recommendation algorithm process for providing users with wines that align with their preferences.

\section{UI/UX Design}

In general, the Aggie Wine Glass UI / UX design focused on creating an intuitive, efficient, and engaging experience that seamlessly guides users from preference input to personalized wine recommendations.

\subsection{Preference Collection Flow}

The preference collection process in Aggie Wine Glass was designed with a low-friction sequential interface to encourage maximum user engagement. Users move step-by-step through initial category selection, taste sliders, flavor profiles, and optional food pairings. Each page in the preference collection process is dedicated to a single input, allowing users to maintain an isolated and complete focus on one aspect of their preferences at a time. This reduces cognitive load and promotes more thoughtful and accurate selections. This progressive disclosure approach respects user time and attention while ensuring the thorough collection of necessary preference data.

\subsection{Swipe Cards}

For fine-tuning preferences, a swipe-based card system was implemented. Users are presented with minisets of anonymous wine profiles, which they can quickly "like" or "dislike." This Tinder-inspired design choice provides an intuitive and lightweight way to refine preferences without overwhelming the user with technical information. Additionally, adapting the mini-sets dynamically based on user feedback enhances perceived personalization, giving users a sense of active involvement in shaping their recommendations. The pun-based loading messages keep usersâ€™ attention and make the experience more fun and enjoyable.

\subsection{Recommendation Display and Interaction}

The final recommendation display balances quick scanning and in-depth exploration. Wines are initially shown with category, name, and star rating to allow fast browsing. Users can tap to expand each wine card, revealing detailed attributes such as restaurant and glass price, flavor specifics, winery, region, and food pairings. This two-tier interaction model prevents information overload while still supporting power users who wish to dive deeper. 

\section{Conclusion}
Aggie Wine Glass successfully addresses a gap in the local wine discovery market by providing an intuitive, data-driven recommendation tool tailored to by-the-glass wine options in College Station. Through a combination of custom data collection, web scraping, LLM-assisted processing, and fine-tuned similarity algorithms, the system delivers highly personalized wine suggestions to the user. Our careful UI/UX design choices further enhanced user engagement, balancing simplicity and depth to make wine exploration approachable even for beginners.

Future work could focus on scaling the system by enabling direct restaurant participation, improving the accuracy of menu updates, and expanding the recommendation model to include live inventory data. Furthermore, a deeper integration with real-time user feedback and regional event recommendations could broaden the impact of the app within the community. Aggie Wine Glass demonstrates a way to make wine more approachable to college students through a personalized recommendation system.

\end{document}
